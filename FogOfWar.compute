// FogOfWar.compute
#pragma kernel CSMain

RWTexture2D<float> Result;              // 1-channel visibility output
Texture2D<float> OcclusionTex;         // Obstacle data (black = blocked)
SamplerState sampler_OcclusionTex;

StructuredBuffer<float4> Observers;    // Each float4: (x, y = world pos), z = radius, w = unused
int ObserverCount;

float2 WorldMin;
float2 WorldMax;
int2 TextureSize;

[numthreads(8,8,1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= TextureSize.x || id.y >= TextureSize.y) return;

    float2 uv = (float2(id.xy) + 0.5) / TextureSize;
    float2 worldPos = lerp(WorldMin, WorldMax, uv);
    float visible = 0;

    for (int i = 0; i < ObserverCount; ++i)
    {
        float2 origin = Observers[i].xy;
        float radius = Observers[i].z;
        float dist = distance(origin, worldPos);
        if (dist > radius) continue;

        float2 dir = normalize(worldPos - origin);
        bool blocked = false;
        const int steps = 64;
        for (int s = 0; s < steps; ++s)
        {
            float t = s / (float)(steps - 1);
            float2 sample = origin + dir * dist * t;
            float2 sampleUV = (sample - WorldMin) / (WorldMax - WorldMin);
            float occ = OcclusionTex.SampleLevel(sampler_OcclusionTex, sampleUV, 0).r;
            if (occ < 0.5) // Black = obstacle
            {
                blocked = true;
                break;
            }
        }

        if (!blocked)
        {
            visible = 1;
            break; // No need to test other observers
        }
    }

    Result[id.xy] = visible;
}
