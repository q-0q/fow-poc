#pragma kernel CSMain

RWTexture3D<float> ResultVolume;
Texture2D<float> OcclusionTex;
SamplerState sampler_OcclusionTex;

StructuredBuffer<float4> Observers; // float4(x, y, z, radius)
int ObserverCount;

float3 WorldMin;
float3 WorldMax;
int3 VolumeSize;

[numthreads(8,8,1)]
void CSMain(uint3 id : SV_DispatchThreadID)
{
    // Bounds check
    if (id.x >= VolumeSize.x || id.y >= VolumeSize.y || id.z >= VolumeSize.z) return;

    // Normalize voxel coordinate to [0,1] in 3D texture space
    float3 voxelNorm;
    voxelNorm.x = (id.x + 0.5f) / VolumeSize.x;
    voxelNorm.y = (id.y + 0.5f) / VolumeSize.y;
    voxelNorm.z = (id.z + 0.5f) / VolumeSize.z;

    // Map to world position
    float3 worldPos = lerp(WorldMin, WorldMax, voxelNorm);

    // Sample occlusion texture (top-down view, XZ)
    float2 uvOcc = (worldPos.xz - WorldMin.xz) / (WorldMax.xz - WorldMin.xz);
    float occlusion = OcclusionTex.SampleLevel(sampler_OcclusionTex, uvOcc, 0).r;

    float visible = 0.0f;

    // Only proceed if not occluded (i.e., walkable space)
    if (occlusion >= 0.5f)
    {
        for (int i = 0; i < ObserverCount; ++i)
        {
            float2 observerPosFlat = float2(Observers[i].x, Observers[i].z);
            float2 worldPosFlat = float2(worldPos.x, worldPos.z);
            float radius = Observers[i].w;

            float2 toVoxel = worldPosFlat - observerPosFlat;
            float dist = length(toVoxel);

            if (dist <= radius)
            {
                visible = 1.0f;
                break;
            }
        }
    }
    else
    {
        // Always reveal obstacles (so they show up in slice view)
        visible = 1.0f;
    }

    // Optional vertical fade to simulate fog falloff near top/bottom
    // float heightNorm = (worldPos.y - WorldMin.y) / (WorldMax.y - WorldMin.y);
    // float verticalFade = smoothstep(0.1, 0.0, heightNorm) * smoothstep(0.9, 1.0, heightNorm);

    ResultVolume[id.xyz] = visible;
}
